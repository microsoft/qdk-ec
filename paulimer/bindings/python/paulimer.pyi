from enum import IntEnum
from typing import (
    Literal,
    final,
    Optional,
    Any,
    Iterable,
    Protocol,
    Sequence,
    overload,
)
from binar import BitMatrix, BitVector

PauliCharacter = Literal["I", "X", "Y", "Z"]
Exponent = int

class UnitaryOpcode(IntEnum):
    I = 0
    X = 1
    Y = 2
    Z = 3
    SqrtX = 4
    SqrtXInv = 5
    SqrtY = 6
    SqrtYInv = 7
    SqrtZ = 8
    SqrtZInv = 9
    Hadamard = 10
    Swap = 11
    ControlledX = 12
    ControlledZ = 13
    PrepareBell = 14

    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    @staticmethod
    def from_string(s: str) -> "UnitaryOpcode": ...

@final
class DensePauli:
    def __init__(self, characters: str="") -> None: ...
    @staticmethod
    def identity(size: int) -> "DensePauli": ...
    @staticmethod
    def x(index: int, size: int) -> "DensePauli": ...
    @staticmethod
    def y(index: int, size: int) -> "DensePauli": ...
    @staticmethod
    def z(index: int, size: int) -> "DensePauli": ...
    @staticmethod
    def from_sparse(pauli: "SparsePauli", size: int) -> "DensePauli": ...
    @property
    def exponent(self) -> Exponent: 
        ### The value of `exponent`, when `self` is written in the form e**(iπ * exponent / 4) XᵃZᵇ.
        ...
    @property
    def phase(self) -> complex: 
        ### The complex phase of `self` when written in tensor product form e**(iπθ) P₁⊗P₂..., i.e., one of {1, i, -1, -i}.
        ...
    @property
    def characters(self) -> str: ...
    @property
    def support(self) -> list[int]: ...
    @property
    def weight(self) -> int: ...
    @property
    def size(self) -> int: ...
    def commutes_with(self, other: "DensePauli" | Iterable["DensePauli"]) -> bool: ...
    def copy(self) -> "DensePauli": ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __mul__(self, other: "DensePauli") -> "DensePauli": ...
    def __imul__(self, other: "DensePauli") -> "DensePauli": ...
    def __add__(self, other: "DensePauli") -> "DensePauli": ...
    def __abs__(self) -> "DensePauli": ...
    def __neg__(self) -> "DensePauli": ...
    def __getitem__(self, index: int) -> PauliCharacter: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, state: tuple) -> None: ...

@final
class SparsePauli:
    @overload
    def __init__(self, characters: str = "") -> None: ...
    @overload
    def __init__(self, characters: dict[int, PauliCharacter], exponent: Exponent = 0) -> None: ...
    @staticmethod
    def identity() -> "SparsePauli": ...
    @staticmethod
    def x(index: int) -> "SparsePauli": ...
    @staticmethod
    def y(index: int) -> "SparsePauli": ...
    @staticmethod
    def z(index: int) -> "SparsePauli": ...
    @staticmethod
    def from_dense(dense_pauli: DensePauli) -> "SparsePauli": ...
    @property
    def exponent(self) -> Exponent: ...
    @property
    def phase(self) -> complex: ...
    @property
    def support(self) -> tuple[int]: ...
    @property
    def characters(self) -> str: ...
    @property
    def weight(self) -> int: ...
    def commutes_with(self, other: "SparsePauli" | Iterable["SparsePauli"]) -> bool: ...
    def copy(self) -> "SparsePauli": ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __mul__(self, other: "SparsePauli") -> "SparsePauli": ...
    def __imul__(self, other: "SparsePauli") -> "SparsePauli": ...
    def __abs__(self) -> "SparsePauli": ...
    def __neg__(self) -> "SparsePauli": ...
    def __getitem__(self, index: int) -> PauliCharacter: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, state: tuple) -> None: ...


@final
class PauliGroup:
    def __init__(self, generators: Iterable[SparsePauli], all_commute: Optional[bool] = None) -> None: ...
    def factorization_of(self, element: SparsePauli) -> Optional[list[SparsePauli]]: ...
    def factorizations_of(self, elements: Iterable[SparsePauli]) -> list[Optional[list[SparsePauli]]]: ...
    def __contains__(self, element: SparsePauli) -> bool: ...
    def __eq__(self, other: Any) -> bool: ...
    def __le__(self, other: "PauliGroup") -> bool: ...
    def __lt__(self, other: "PauliGroup") -> bool: ...
    def __or__(self, other: "PauliGroup") -> "PauliGroup": ...
    def __and__(self, other: "PauliGroup") -> "PauliGroup": ...
    def __truediv__(self, other: "PauliGroup") -> "PauliGroup": ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, state: tuple) -> None: ...
    
    @property
    def generators(self) -> list[SparsePauli]: ...
    @property
    def standard_generators(self) -> list[SparsePauli]: ...
    @property
    def elements(self) -> Iterable[SparsePauli]: ...
    @property
    def phases(self) -> list[Exponent]: ...
    @property
    def binary_rank(self) -> int: ...
    @property
    def support(self) -> list[int]: ...
    @property
    def log2_size(self) -> int: ...
    @property
    def is_abelian(self) -> bool: ...
    @property
    def is_stabilizer_group(self) -> bool: ...


def centralizer_of(group: PauliGroup, supported_by: Optional[Iterable[int]]=None) -> PauliGroup: ...
def symplectic_form_of(generators: Iterable[SparsePauli]) -> Iterable[SparsePauli]: ...

@final
class CliffordUnitary:
    @staticmethod
    def from_string(characters: str) -> "CliffordUnitary":
        """For example, creates one qubit Hadamard from string "X_0:Z_0, Z_0:X_0" """
        ...
    @staticmethod
    def from_preimages(preimages: Sequence[DensePauli]) -> "CliffordUnitary": ...
    @staticmethod
    def from_images(images: Sequence[DensePauli]) -> "CliffordUnitary": ...
    @staticmethod
    def from_symplectic_matrix(matrix: BitMatrix) -> "CliffordUnitary": ...
    @staticmethod
    def from_name(name: str, operands: Sequence[int], qubit_count: int) -> "CliffordUnitary": ...
    @staticmethod
    def identity(qubit_count: int) -> "CliffordUnitary": ...

    @property
    def is_css(self) -> bool: ...
    @property
    def qubit_count(self) -> int: ...
    @property
    def is_valid(self) -> bool: ...
    @property
    def is_identity(self) -> bool: ...

    def preimage_of(self, pauli: DensePauli | SparsePauli) -> DensePauli: ...
    def preimage_x(self, index: int) -> DensePauli: ...
    def preimage_z(self, index: int) -> DensePauli: ...
    def image_of(self, pauli: DensePauli | SparsePauli) -> DensePauli: ...
    def image_x(self, index: int) -> DensePauli: ...
    def image_z(self, index: int) -> DensePauli: ...
    def tensor(self, rhs: "CliffordUnitary") -> "CliffordUnitary": ...
    def inverse(self) -> "CliffordUnitary": ...
    def is_diagonal(self, axis: Literal["X", "Z"]) -> bool: ...
    def symplectic_matrix(self) -> BitMatrix: ...
    def __mul__(self, other: "CliffordUnitary") -> "CliffordUnitary": ...
    def left_mul(self, opcode: UnitaryOpcode, operands: Sequence[int]) -> None: ...
    def left_mul_clifford(
        self, clifford: "CliffordUnitary", support: Sequence[int]
    ) -> None: ...
    def left_mul_permutation(
        self, permutation: Sequence[int], support: Sequence[int]
    ) -> None: ...
    def left_mul_pauli(self, pauli: DensePauli | SparsePauli) -> None: ...
    def left_mul_pauli_exp(self, pauli: DensePauli | SparsePauli) -> None: ...
    def left_mul_controlled_pauli(
        self, control: DensePauli | SparsePauli, target: DensePauli | SparsePauli
    ) -> None: ...
    def __pow__(self, exponent: int) -> "CliffordUnitary": ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, state: tuple) -> None: ...


def is_diagonal_resource_encoder(clifford: CliffordUnitary, axis: Literal["X", "Z"]) -> bool: ...
def unitary_from_diagonal_resource_state(clifford: CliffordUnitary, axis: Literal["X", "Z"]) -> "CliffordUnitary" | None: ...
def split_qubit_cliffords_and_css(clifford: CliffordUnitary) -> tuple["CliffordUnitary", "CliffordUnitary"] | None: ...
def split_phased_css(clifford: CliffordUnitary) -> tuple["CliffordUnitary", "CliffordUnitary"] | None: ...
def encoding_clifford_of(generators: Sequence[SparsePauli | DensePauli], qubit_count: int) -> "CliffordUnitary": ...


class StabilizerSimulation(Protocol):

    @property
    def qubit_count(self) -> int: ...
    @property
    def qubit_capacity(self) -> int: ...
    @property
    def outcome_count(self) -> int: ...
    @property
    def outcome_capacity(self) -> int: ...
    @property
    def random_outcome_count(self) -> int: ...
    @property
    def random_outcome_capacity(self) -> int: ...
    @property
    def random_bit_count(self) -> int: ...

    def apply_unitary(self, unitary_op: UnitaryOpcode, support: Sequence[int]) -> None: ...
    def apply_pauli_exp(self, observable: SparsePauli) -> None: ...
    def apply_pauli(self, observable: SparsePauli, controlled_by: SparsePauli | None = None) -> None: ...
    def apply_conditional_pauli(
        self, observable: SparsePauli, outcomes: Sequence[int], parity: bool = True,
    ) -> None: ...
    def apply_permutation(self, permutation: Sequence[int], supported_by: Sequence[int] | None = None) -> None: ...
    def apply_clifford(self, clifford: CliffordUnitary, supported_by: Sequence[int] | None = None) -> None: ...
    def measure(self, observable: SparsePauli, hint: SparsePauli | None = None) -> None: ...

    def allocate_random_bit(self) -> int: ...
    def reserve_qubits(self, new_qubit_capacity: int) -> None: ...
    def reserve_outcomes(self, new_outcome_capacity: int, new_random_outcome_capacity: int) -> None: ...

    def is_stabilizer(self, observable: SparsePauli, ignore_sign: bool = False) -> bool: ...


@final
class OutcomeCompleteSimulation:
    def __init__(self, num_qubits: int = 0) -> None: ...

    @property
    def qubit_count(self) -> int: ...
    @property
    def qubit_capacity(self) -> int: ...
    @property
    def outcome_count(self) -> int: ...
    @property
    def outcome_capacity(self) -> int: ...
    @property
    def random_outcome_count(self) -> int: ...
    @property
    def random_outcome_capacity(self) -> int: ...
    @property
    def random_bit_count(self) -> int: ...

    def apply_unitary(self, unitary_op: UnitaryOpcode, support: Sequence[int]) -> None: ...
    def apply_pauli_exp(self, observable: SparsePauli) -> None: ...
    def apply_pauli(self, observable: SparsePauli, controlled_by: SparsePauli | None = None) -> None: ...
    def apply_conditional_pauli(
        self, observable: SparsePauli, outcomes: Sequence[int], parity: bool = True,
    ) -> None: ...
    def apply_permutation(self, permutation: Sequence[int], supported_by: Sequence[int] | None = None) -> None: ...
    def apply_clifford(self, clifford: CliffordUnitary, supported_by: Sequence[int] | None = None) -> None: ...
    def measure(self, observable: SparsePauli, hint: SparsePauli | None = None) -> None: ...

    def allocate_random_bit(self) -> int: ...
    def reserve_qubits(self, new_qubit_capacity: int) -> None: ...
    def reserve_outcomes(self, new_outcome_capacity: int, new_random_outcome_capacity: int) -> None: ...

    def is_stabilizer(self, observable: SparsePauli, ignore_sign: bool = False, sign_parity: Sequence[int] | None = None) -> bool: ...

    @staticmethod
    def with_capacity(
        qubit_count: int, outcome_count: int, random_outcome_count: int
    ) -> "OutcomeCompleteSimulation": ...

    @property
    def random_outcome_indicator(self) -> BitVector: ...
    @property
    def clifford(self) -> CliffordUnitary: ...
    @property
    def sign_matrix(self) -> BitMatrix: ...
    @property
    def outcome_matrix(self) -> BitMatrix: ...
    @property
    def outcome_shift(self) -> BitVector: ...


@final
class OutcomeFreeSimulation:
    def __init__(self, num_qubits: int = 0) -> None: ...

    @property
    def qubit_count(self) -> int: ...
    @property
    def qubit_capacity(self) -> int: ...
    @property
    def outcome_count(self) -> int: ...
    @property
    def outcome_capacity(self) -> int: ...
    @property
    def random_outcome_count(self) -> int: ...
    @property
    def random_outcome_capacity(self) -> int: ...
    @property
    def random_bit_count(self) -> int: ...

    def apply_unitary(self, unitary_op: UnitaryOpcode, support: Sequence[int]) -> None: ...
    def apply_pauli_exp(self, observable: SparsePauli) -> None: ...
    def apply_pauli(self, observable: SparsePauli, controlled_by: SparsePauli | None = None) -> None: ...
    def apply_conditional_pauli(
        self, observable: SparsePauli, outcomes: Sequence[int], parity: bool = True,
    ) -> None: ...
    def apply_permutation(self, permutation: Sequence[int], supported_by: Sequence[int] | None = None) -> None: ...
    def apply_clifford(self, clifford: CliffordUnitary, supported_by: Sequence[int] | None = None) -> None: ...
    def measure(self, observable: SparsePauli, hint: SparsePauli | None = None) -> None: ...

    def allocate_random_bit(self) -> int: ...
    def reserve_qubits(self, new_qubit_capacity: int) -> None: ...
    def reserve_outcomes(self, new_outcome_capacity: int, new_random_outcome_capacity: int) -> None: ...

    def is_stabilizer(self, observable: SparsePauli, ignore_sign: bool = False, sign_parity: Sequence[int] | None = None) -> bool: ...

    @staticmethod
    def with_capacity(
        qubit_count: int, outcome_count: int, random_outcome_count: int
    ) -> "OutcomeFreeSimulation": ...

    @property
    def random_outcome_indicator(self) -> BitVector: ...
    @property
    def clifford(self) -> CliffordUnitary: ...


@final
class OutcomeSpecificSimulation:
    def __init__(self, num_qubits: int = 0) -> None: ...

    @property
    def qubit_count(self) -> int: ...
    @property
    def qubit_capacity(self) -> int: ...
    @property
    def outcome_count(self) -> int: ...
    @property
    def outcome_capacity(self) -> int: ...
    @property
    def random_outcome_count(self) -> int: ...
    @property
    def random_outcome_capacity(self) -> int: ...
    @property
    def random_bit_count(self) -> int: ...

    def apply_unitary(self, unitary_op: UnitaryOpcode, support: Sequence[int]) -> None: ...
    def apply_pauli_exp(self, observable: SparsePauli) -> None: ...
    def apply_pauli(self, observable: SparsePauli, controlled_by: SparsePauli | None = None) -> None: ...
    def apply_conditional_pauli(
        self, observable: SparsePauli, outcomes: Sequence[int], parity: bool = True,
    ) -> None: ...
    def apply_permutation(self, permutation: Sequence[int], supported_by: Sequence[int] | None = None) -> None: ...
    def apply_clifford(self, clifford: CliffordUnitary, supported_by: Sequence[int] | None = None) -> None: ...
    def measure(self, observable: SparsePauli, hint: SparsePauli | None = None) -> None: ...

    def allocate_random_bit(self) -> int: ...
    def reserve_qubits(self, new_qubit_capacity: int) -> None: ...
    def reserve_outcomes(self, new_outcome_capacity: int, new_random_outcome_capacity: int) -> None: ...

    def is_stabilizer(self, observable: SparsePauli, ignore_sign: bool = False, sign_parity: Sequence[int] | None = None) -> bool: ...

    @staticmethod
    def with_capacity(
        qubit_count: int, outcome_count: int, random_outcome_count: int
    ) -> "OutcomeSpecificSimulation": ...

    @property
    def random_outcome_indicator(self) -> BitVector: ...
    @property
    def outcome_vector(self) -> BitVector: ...


@final
class OutcomeCondition:
    """Condition for applying noise based on measurement outcomes."""
    def __init__(self, outcomes: Sequence[int], parity: bool = True) -> None: ...
    @property
    def outcomes(self) -> list[int]: ...
    @property
    def parity(self) -> bool: ...
    def __repr__(self) -> str: ...


@final
class PauliDistribution:
    """Distribution over Paulis for sampling faults."""
    @staticmethod
    def depolarizing(qubits: Sequence[int]) -> "PauliDistribution":
        """Uniform over all non-identity Paulis on the given qubits."""
        ...
    @staticmethod
    def single(pauli: SparsePauli) -> "PauliDistribution":
        """Single deterministic Pauli."""
        ...
    @staticmethod
    def uniform(paulis: Sequence[SparsePauli]) -> "PauliDistribution":
        """Uniform distribution over an explicit list of Paulis."""
        ...
    @staticmethod
    def weighted(pairs: Sequence[tuple[SparsePauli, float]]) -> "PauliDistribution":
        """Weighted distribution from (Pauli, weight) pairs."""
        ...
    @property
    def elements(self) -> list[tuple[SparsePauli, float]]:
        """All elements as (SparsePauli, probability) pairs."""
        ...
    def __repr__(self) -> str: ...


@final
class PauliFault:
    """A fault specification describing a noise source."""
    def __init__(
        self,
        probability: float,
        distribution: PauliDistribution,
        correlation_id: int | None = None,
        condition: OutcomeCondition | None = None,
    ) -> None: ...
    @staticmethod
    def depolarizing(probability: float, qubits: Sequence[int]) -> "PauliFault":
        """Create a simple depolarizing noise on the given qubits."""
        ...
    @property
    def probability(self) -> float: ...
    @property
    def distribution(self) -> PauliDistribution: ...
    @property
    def correlation_id(self) -> int | None: ...
    @property
    def condition(self) -> OutcomeCondition | None: ...
    def __repr__(self) -> str: ...


@final
class FaultySimulation:
    """Frame-based noisy simulation with circuit-builder interface.
    
    Implements the StabilizerSimulation protocol: call gate methods to build
    a circuit, then call sample() to get noisy outcomes.
    
    Example:
        sim = FaultySimulation()
        sim.apply_unitary(UnitaryOpcode.Hadamard, [0])
        sim.apply_unitary(UnitaryOpcode.ControlledX, [0, 1])
        sim.measure(SparsePauli("ZI"))
        sim.measure(SparsePauli("IZ"))
        sim.apply_fault(PauliFault.depolarizing(0.01, [0, 1]))
        outcomes = sim.sample(1000)
    """
    def __init__(
        self,
        qubit_count: int | None = None,
        outcome_count: int | None = None,
        instruction_count: int | None = None,
    ) -> None:
        """Create a new simulation.
        
        Args:
            qubit_count: Expected number of qubits (optional, for pre-allocation).
            outcome_count: Expected number of measurement outcomes (optional).
            instruction_count: Expected number of instructions (optional).
        
        Pre-allocating capacity can improve performance for large circuits.
        """
        ...
    
    # Properties
    @property
    def qubit_count(self) -> int: ...
    @property
    def outcome_count(self) -> int: ...
    @property
    def fault_count(self) -> int: ...
    
    # Gate methods (StabilizerSimulation protocol)
    def apply_unitary(self, opcode: UnitaryOpcode, qubits: Sequence[int]) -> None: ...
    def apply_clifford(self, clifford: CliffordUnitary, qubits: Sequence[int] | None = None) -> None: ...
    def apply_pauli(self, pauli: SparsePauli, controlled_by: SparsePauli | None = None) -> None: ...
    def apply_pauli_exp(self, pauli: SparsePauli) -> None: ...
    def apply_permutation(self, permutation: Sequence[int], qubits: Sequence[int] | None = None) -> None: ...
    def apply_conditional_pauli(self, pauli: SparsePauli, outcomes: Sequence[int], parity: bool = True) -> None: ...
    def measure(self, observable: SparsePauli, hint: SparsePauli | None = None) -> int:
        """Measure an observable, returning the outcome index."""
        ...
    def allocate_random_bit(self) -> int:
        """Allocate a random bit, returning the outcome index."""
        ...
    
    # Noise methods
    def apply_fault(self, fault: PauliFault) -> None:
        """Add a fault (noise) instruction."""
        ...
    
    # Sampling
    def sample(self, shots: int, seed: int | None = None) -> BitMatrix: ...
    def __repr__(self) -> str: ...